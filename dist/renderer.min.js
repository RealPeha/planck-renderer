class CanvasRenderer{constructor(t,e,s={}){const n={scale:16,lineWidth:1/16,strokeStyle:{dynamic:"black",static:"black",kinematic:"black"}};this.options=Object.assign(n,s),s.lineWidth||(this.options.lineWidth=1/this.options.scale),this.world=t,this.ctx=e,this.canvas=e.canvas,this.draw=null,this.clear=((t,e)=>{e.clearRect(0,0,t.width,t.height)})}renderWorld(){const{ctx:t,canvas:e,options:s}=this;this.clear(e,t),"function"==typeof this.draw&&this.draw(t);for(let e=this.world.getBodyList();e;e=e.getNext())for(let n=e.getFixtureList();n;n=n.getNext()){if(e.render&&e.render.hidden)continue;e.render&&e.render.stroke?t.strokeStyle=e.render.stroke:e.isDynamic()?t.strokeStyle=s.strokeStyle.dynamic:e.isKinematic()?t.strokeStyle=s.strokeStyle.kinematic:e.isStatic()&&(t.strokeStyle=s.strokeStyle.static);const r=n.getType(),i=n.getShape();t.save(),t.scale(this.options.scale,this.options.scale),t.lineWidth=s.lineWidth,"circle"===r&&this.drawCircle(e,i),"edge"===r&&this.drawEdge(e,i),"polygon"===r&&this.drawPolygon(e,i),"chain"===r&&this.drawPolygon(e,i),t.restore()}for(let e=this.world.getJointList();e;e=e.getNext())t.save(),t.scale(this.options.scale,this.options.scale),this.drawJoint(e),t.restore()}drawCircle(t,e){const s=this.ctx,n=this.options.lineWidth,r=e.m_radius,i=t.getPosition(),o=t.getAngle(),a=2*r+2*n;if(s.translate(i.x+n,i.y+n),s.rotate(o),t.render&&t.render.custom){const e={x:-r-2*n,y:-r-2*n};if(!0!==t.render.custom(s,e,a+n))return}s.beginPath(),s.arc(0,0,r,0,2*Math.PI),s.stroke(),s.restore()}drawEdge(t,e){const s=this.ctx,n=this.options.lineWidth,r=e.m_vertex1,i=e.m_vertex2,o=i.x-r.x,a=i.y-r.y,c=Math.sqrt(o*o+a*a);s.translate(r.x+n,r.y+n),s.beginPath(),s.moveTo(n,n),s.lineTo(n+c,n),s.lineCap="round",s.stroke()}drawPolygon(t,e){const s=this.ctx,n=this.options.lineWidth,r=e.m_vertices;if(!r.length)return;let i=1/0,o=1/0,a=-1/0,c=-1/0;for(const t of r)i=Math.min(i,t.x),a=Math.max(a,t.x),o=Math.min(o,t.y),c=Math.max(c,t.y);const h=a-i,l=c-o,d=t.getPosition(),u=t.getAngle();if(s.translate(d.x+2*n,d.y+2*n),s.rotate(u),t.render&&t.render.custom){const e={width:h+n,height:l+n},r={x:i-n,y:o-n};if(!0!==t.render.custom(s,r,e))return}s.beginPath();for(let t=0;t<r.length;++t){const e=r[t],i=e.x-n,o=e.y-n;0===t?s.moveTo(i,o):s.lineTo(i,o)}r.length>2&&s.closePath(),s.stroke()}drawJoint(t){const e=this.ctx,s=t.getAnchorA(),n=t.getAnchorB();e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()}}export{CanvasRenderer};class Runner{constructor(t,e={}){this.options=Object.assign({fps:60,speed:1},e),this.world=t,this.fps=0,this.runId=null,this.render=null,this.update=null}start(t=!1,e=!1){if(this.runId)return;t&&(this.render=t),e&&(this.update=t);const s=1/this.options.fps,n=1/this.options.speed*s;let r,i,o=performance.now(),a=0;const c=()=>{for(r=performance.now(),a+=Math.min(1,(r-o)/1e3);a>n;)this.world.step(s),"function"==typeof e&&this.update(s),a-=n;i=(r-o)/1e3,this.fps=1/i,o=r,this.render(),this.runId=requestAnimationFrame(c)};this.runId=requestAnimationFrame(c)}stop(){this.runId&&(cancelAnimationFrame(this.runId),this.runId=null)}}export{Runner};class SVGRenderer{constructor(){throw new Error("Your browser does not support the canvas element")}}export{SVGRenderer};const canvas=()=>!!document.createElement("canvas").getContext("2d"),Renderer=canvas()?CanvasRenderer:SVGRenderer;export default Renderer;